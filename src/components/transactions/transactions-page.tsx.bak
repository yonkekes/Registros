'use client';
import { useState, useMemo, useRef } from 'react';
import { Button } from '@/components/ui/button';
import { PlusCircle, Upload } from 'lucide-react';
import { TransactionsTable } from './transactions-table';
import { AddTransactionSheet } from './add-transaction-sheet';
import { useTransactions } from '@/contexts/transactions-context';
import { Category, categories, incomeCategories, expenseCategories, Transaction } from '@/lib/types';
import { Input } from '@/components/ui/input';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import * as XLSX from 'xlsx';
import { useToast } from '@/hooks/use-toast';


export default function TransactionsPage() {
  const { addMultipleTransactions } = useTransactions();
  const [sheetOpen, setSheetOpen] = useState(false);
  const [editingTransactionId, setEditingTransactionId] = useState<
    string | null
  >(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [typeFilter, setTypeFilter] = useState<'all' | 'income' | 'expense'>('all');
  const [categoryFilter, setCategoryFilter] = useState<Category | 'all'>('all');
  const [sortConfig, setSortConfig] = useState<{
    key: 'date' | 'amount';
    direction: 'asc' | 'desc';
  }>({ key: 'date', direction: 'desc' });
  const fileInputRef = useRef<HTMLInputElement>(null);
  const { toast } = useToast();

  const { transactions } = useTransactions();

  const handleEdit = (id: string) => {
    setEditingTransactionId(id);
    setSheetOpen(true);
  };

  const handleAdd = () => {
    setEditingTransactionId(null);
    setSheetOpen(true);
  };
  
  const handleSheetClose = (open: boolean) => {
    setSheetOpen(open);
    if (!open) {
      setEditingTransactionId(null);
    }
  };

  const sortedAndFilteredTransactions = useMemo(() => {
    let filtered = transactions;

    if (typeFilter !== 'all') {
      filtered = filtered.filter(t => t.type === typeFilter);
    }

    if (categoryFilter !== 'all') {
      filtered = filtered.filter(t => t.category === categoryFilter);
    }

    if (searchTerm) {
      filtered = filtered.filter(t =>
        t.description.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }

    return [...filtered].sort((a, b) => {
      if (sortConfig.key === 'date') {
        const dateA = new Date(a.date).getTime();
        const dateB = new Date(b.date).getTime();
        return sortConfig.direction === 'asc' ? dateA - dateB : dateB - dateA;
      } else {
        return sortConfig.direction === 'asc'
          ? a.amount - b.amount
          : b.amount - a.amount;
      }
    });
  }, [transactions, typeFilter, categoryFilter, searchTerm, sortConfig]);

  const handleSort = (key: 'date' | 'amount') => {
    setSortConfig(prev => ({
        key,
        direction: prev.key === key && prev.direction === 'desc' ? 'asc' : 'desc'
    }));
  }

  const availableCategories = useMemo(() => {
    if (typeFilter === 'income') return incomeCategories;
    if (typeFilter === 'expense') return expenseCategories;
    return categories;
  }, [typeFilter])
  
  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = new Uint8Array(e.target?.result as ArrayBuffer);
          const workbook = XLSX.read(data, { type: 'array', cellDates: true });
          const sheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[sheetName];
          const json: any[] = XLSX.utils.sheet_to_json(worksheet);

          const newTransactions: Omit<Transaction, 'id'>[] = [];
          
          json.forEach((row) => {
            // Normalize keys to lowercase and trim spaces
            const lowerRow = Object.keys(row).reduce((acc, key) => {
                acc[key.toLowerCase().trim()] = row[key];
                return acc;
            }, {} as any);

            const { fecha, descripcion, monto, tipo, categoria, comentarios } = lowerRow;

            // Basic validation
            if (fecha && descripcion && monto && tipo && categoria) {
              const newTransaction = {
                date: new Date(fecha).toISOString(),
                description: String(descripcion),
                amount: parseFloat(monto),
                type: String(tipo).toLowerCase() as 'income' | 'expense',
                category: String(categoria) as Category,
                comments: comentarios ? String(comentarios) : undefined,
              };

              // More validation
              if (!isNaN(newTransaction.amount) && categories.includes(newTransaction.category)) {
                newTransactions.push(newTransaction);
              }
            }
          });
          
          if (newTransactions.length > 0) {
            addMultipleTransactions(newTransactions);
            toast({
              title: "Importación Exitosa",
              description: `Se importaron ${newTransactions.length} transacciones.`,
            });
          } else {
             toast({
              variant: "destructive",
              title: "Error de Importación",
              description: "No se encontraron transacciones válidas en el archivo.",
            });
          }

        } catch (error) {
          console.error("Error al importar el archivo:", error);
          toast({
            variant: "destructive",
            title: "Error de Importación",
            description: "No se pudo procesar el archivo. Asegúrate de que el formato sea correcto y las columnas tengan los nombres: Fecha, Descripcion, Monto, Tipo, Categoria.",
          });
        }
      };
      reader.readAsArrayBuffer(file);
    }
     // Reset file input
    if (fileInputRef.current) {
        fileInputRef.current.value = '';
    }
  };

  const handleImportClick = () => {
    fileInputRef.current?.click();
  };

  return (
    <div className="flex-1 space-y-4 p-4 md:p-8 pt-6">
      <div className="flex items-center justify-between space-y-2">
        <h2 className="text-3xl font-bold tracking-tight font-headline">Transacciones</h2>
        <div className='flex gap-2'>
            <input
                type="file"
                ref={fileInputRef}
                onChange={handleFileUpload}
                className="hidden"
                accept=".xlsx"
            />
            <Button onClick={handleImportClick} variant="outline">
                <Upload className="mr-2 h-4 w-4" /> Importar Excel
            </Button>
            <Button onClick={handleAdd}>
                <PlusCircle className="mr-2 h-4 w-4" /> Añadir Transacción
            </Button>
        </div>
      </div>

      <div className="flex flex-col md:flex-row gap-2 items-center">
        <Input
          placeholder="Filtrar por descripción..."
          value={searchTerm}
          onChange={e => setSearchTerm(e.target.value)}
          className="max-w-sm"
        />
        <Select value={typeFilter} onValueChange={(v) => {
            setTypeFilter(v as any);
            setCategoryFilter('all');
        }}>
            <SelectTrigger className='w-full md:w-[180px]'>
                <SelectValue placeholder="Filtrar por tipo" />
            </SelectTrigger>
            <SelectContent>
                <SelectItem value="all">Todos los Tipos</SelectItem>
                <SelectItem value="income">Ingreso</SelectItem>
                <SelectItem value="expense">Gasto</SelectItem>
            </SelectContent>
        </Select>
         <Select value={categoryFilter} onValueChange={(v) => setCategoryFilter(v as any)}>
            <SelectTrigger className='w-full md:w-[180px]'>
                <SelectValue placeholder="Filtrar por categoría" />
            </SelectTrigger>
            <SelectContent>
                <SelectItem value="all">Todas las Categorías</SelectItem>
                {availableCategories.map(cat => (
                    <SelectItem key={cat} value={cat}>{cat}</SelectItem>
                ))}
            </SelectContent>
        </Select>
      </div>

      <TransactionsTable
        transactions={sortedAndFilteredTransactions}
        onEdit={handleEdit}
        sortConfig={sortConfig}
        onSort={handleSort}
      />
      <AddTransactionSheet
        open={sheetOpen}
        onOpenChange={handleSheetClose}
        transactionId={editingTransactionId}
      />
    </div>
  );
}
